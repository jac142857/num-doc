   <div class="col-md-9" id="content">
      
      <p>There are two different types of transactions in Ethereum: plain value transfers and
contract executions. A plain value transfer just moves Ether from one account to another
and as such is uninteresting from this guide’s perspective. If however the recipient of a
transaction is a contract account with associated EVM (Ethereum Virtual Machine)
bytecode - beside transferring any Ether - the code will also be executed as part of the
transaction.</p>

<p>Having code associated with Ethereum accounts permits transactions to do arbitrarily
complex data storage and enables them to act on the previously stored data by further
transacting internally with outside accounts and contracts. This creates an intertwined
ecosystem of contracts, where a single transaction can interact with tens or hundreds of
accounts.</p>

<p>The downside of contract execution is that it is very hard to say what a transaction
actually did. A transaction receipt does contain a status code to check whether execution
succeeded or not, but there’s no way to see what data was modified, nor what external
contracts where invoked. In order to introspect a transaction, we need to trace its
execution.</p>

<h2 id="tracing-prerequisites">Tracing prerequisites</h2>

<p>In its simplest form, tracing a transaction entails requesting the Ethereum node to
reexecute the desired transaction with varying degrees of data collection and have it
return the aggregated summary for post processing. Reexecuting a transaction however has a
few prerequisites to be met.</p>

<p>In order for an Ethereum node to reexecute a transaction, it needs to have available all
historical state accessed by the transaction:</p>

<ul>
  <li>Balance, nonce, bytecode and storage of both the recipient as well as all internally invoked contracts.</li>
  <li>Block metadata referenced during execution of both the outer as well as all internally created transactions.</li>
  <li>Intermediate state generated by all preceding transactions contained in the same block as the one being traced.</li>
</ul>

<p>Depending on your node’s mode of synchronization and pruning, different configurations
result in different capabilities:</p>

<ul>
  <li>An <strong>archive</strong> node retaining <strong>all historical data</strong> can trace arbitrary transactions
at any point in time. Tracing a single transaction also entails reexecuting all
preceding transactions in the same block.</li>
  <li>A <strong>full synced</strong> node retaining <strong>all historical data</strong> after initial sync can only
trace transactions from blocks following the initial sync point. Tracing a single
transaction also entails reexecuting all preceding transactions in the same block.</li>
  <li>A <strong>fast synced</strong> node retaining only <strong>periodic state data</strong> after initial sync can
only trace transactions from blocks following the initial sync point. Tracing a single
transaction entails reexecuting all preceding transactions <strong>both</strong> in the same block,
as well as all preceding blocks until the previous stored snapshot.</li>
  <li>A <strong>light synced</strong> node retrieving data <strong>on demand</strong> can in theory trace transactions
for which all required historical state is readily available in the network. In
practice, data availability is <strong>not</strong> a feasible assumption.</li>
</ul>

<p><em>There are exceptions to the above rules when running batch traces of entire blocks or
chain segments. Those will be detailed later.</em></p>

<h2 id="basic-traces">Basic traces</h2>

<p>The simplest type of transaction trace that <code class="language-plaintext highlighter-rouge">go-ethereum</code> can generate are raw EVM opcode
traces. For every VM instruction the transaction executes, a structured log entry is
emitted, containing all contextual metadata deemed useful. This includes the <em>program
counter</em>, <em>opcode name</em>, <em>opcode cost</em>, <em>remaining gas</em>, <em>execution depth</em> and any
<em>occurred error</em>. The structured logs can optionally also contain the content of the
<em>execution stack</em>, <em>execution memory</em> and <em>contract storage</em>.</p>

<p>An example log entry for a single opcode looks like:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"pc"</span><span class="p">:</span><span class="w">      </span><span class="mi">48</span><span class="p">,</span><span class="w">
  </span><span class="nl">"op"</span><span class="p">:</span><span class="w">      </span><span class="s2">"DIV"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"gasCost"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
  </span><span class="nl">"gas"</span><span class="p">:</span><span class="w">     </span><span class="mi">64532</span><span class="p">,</span><span class="w">
  </span><span class="nl">"depth"</span><span class="p">:</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"error"</span><span class="p">:</span><span class="w">   </span><span class="kc">null</span><span class="p">,</span><span class="w">
  </span><span class="nl">"stack"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="s2">"00000000000000000000000000000000000000000000000000000000ffffffff"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"0000000100000000000000000000000000000000000000000000000000000000"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"2df07fbaabbe40e3244445af30759352e348ec8bebd4dd75467a9f29ec55d98d"</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"memory"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="s2">"0000000000000000000000000000000000000000000000000000000000000000"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"0000000000000000000000000000000000000000000000000000000000000000"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"0000000000000000000000000000000000000000000000000000000000000060"</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"storage"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>The entire output of an raw EVM opcode trace is a JSON object having a few metadata
fields: <em>consumed gas</em>, <em>failure status</em>, <em>return value</em>; and a list of <em>opcode entries</em>
that take the above form:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"gas"</span><span class="p">:</span><span class="w">         </span><span class="mi">25523</span><span class="p">,</span><span class="w">
  </span><span class="nl">"failed"</span><span class="p">:</span><span class="w">      </span><span class="kc">false</span><span class="p">,</span><span class="w">
  </span><span class="nl">"returnValue"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"structLogs"</span><span class="p">:</span><span class="w">  </span><span class="p">[]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="generating-basic-traces">Generating basic traces</h3>

<p>To generate a raw EVM opcode trace, <code class="language-plaintext highlighter-rouge">go-ethereum</code> provides a few <a href="https://geth.ethereum.org/docs/rpc/ns-debug">RPC API
endpoints</a>, out of which the most commonly used is
<a href="https://geth.ethereum.org/docs/rpc/ns-debug#debug_tracetransaction"><code class="language-plaintext highlighter-rouge">debug_traceTransaction</code></a>.</p>

<p>In its simplest form, <code class="language-plaintext highlighter-rouge">traceTransaction</code> accepts a transaction hash as its sole argument,
traces the transaction, aggregates all the generated data and returns it as a <strong>large</strong>
JSON object. A sample invocation from the Geth console would be:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">debug</span><span class="p">.</span><span class="nx">traceTransaction</span><span class="p">(</span><span class="dl">"</span><span class="s2">0xfc9359e49278b7ba99f59edac0e3de49956e46e530a53c15aa71226b7aa92c6f</span><span class="dl">"</span><span class="p">)</span>
</code></pre></div></div>

<p>The same call can of course be invoked from outside the node too via HTTP RPC. In this
case, please make sure the HTTP endpoint is enabled via <code class="language-plaintext highlighter-rouge">--http</code> and the <code class="language-plaintext highlighter-rouge">debug</code> API
namespace exposed via <code class="language-plaintext highlighter-rouge">--http.api=debug</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl -H "Content-Type: application/json" -d '{"id": 1, "method": "debug_traceTransaction", "params": ["0xfc9359e49278b7ba99f59edac0e3de49956e46e530a53c15aa71226b7aa92c6f"]}' localhost:8545
</code></pre></div></div>

<p>Running the above operation on the Rinkeby network (with a node retaining enough history)
will result in this <a href="https://gist.github.com/karalabe/c91f95ac57f5e57f8b950ec65ecc697f">trace dump</a>.</p>

<h3 id="tuning-basic-traces">Tuning basic traces</h3>

<p>By default the raw opcode tracer emits all relevant events that occur within the EVM while
processing a transaction, such as <em>EVM stack</em>, <em>EVM memory</em> and <em>updated storage slots</em>.
Certain use cases however may not need some of these data fields reported. To cater for
those use cases, these massive fields may be omitted using a second <em>options</em> parameter
for the tracer:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"disableStack"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
  </span><span class="nl">"disableMemory"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
  </span><span class="nl">"disableStorage"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Running the previous tracer invocation from the Geth console with the data fields
disabled:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">debug</span><span class="p">.</span><span class="nx">traceTransaction</span><span class="p">(</span><span class="dl">"</span><span class="s2">0xfc9359e49278b7ba99f59edac0e3de49956e46e530a53c15aa71226b7aa92c6f</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span><span class="na">disableStack</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">disableMemory</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">disableStorage</span><span class="p">:</span> <span class="kc">true</span><span class="p">})</span>
</code></pre></div></div>

<p>Analogously running the filtered tracer from outside the node too via HTTP RPC:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl -H "Content-Type: application/json" -d '{"id": 1, "method": "debug_traceTransaction", "params": ["0xfc9359e49278b7ba99f59edac0e3de49956e46e530a53c15aa71226b7aa92c6f", {"disableStack": true, "disableMemory": true, "disableStorage": true}]}' localhost:8545
</code></pre></div></div>

<p>Running the above operation on the Rinkeby network will result in this significantly
shorter <a href="https://gist.github.com/karalabe/d74a7cb33a70f2af75e7824fc772c5b4">trace dump</a>.</p>

<h3 id="limits-of-basic-traces">Limits of basic traces</h3>

<p>Although the raw opcode traces we’ve generated above have their use, this basic way of
tracing is problematic in the real world. Having an individual log entry for every single
opcode is too low level for most use cases, and will require developers to create
additional tools to post-process the traces. Additionally, a full opcode trace can easily
go into the hundreds of megabytes, making them very resource intensive to get out of the
node and process externally.</p>

<p>To avoid all of the previously mentioned issues, <code class="language-plaintext highlighter-rouge">go-ethereum</code> supports running custom
JavaScript tracers <em>within</em> the Ethereum node, which have full access to the EVM stack,
memory and contract storage. This permits developers to only gather the data they need,
and do any processing <strong>at</strong> the data. Please see the next section for our <em>custom in-node
tracers</em>.</p>

<h3 id="pruning">Pruning</h3>

<p>Geth by default does in-memory pruning of state, discarding state entries that it deems is
no longer necessary to maintain. This is configured via the <code class="language-plaintext highlighter-rouge">--gcmode</code> option. Often,
people run into the error that state is not available.</p>

<p>Say you want to do a trace on block <code class="language-plaintext highlighter-rouge">B</code>. Now there are a couple of cases:</p>

<ol>
  <li>You have done a fast-sync, pivot block <code class="language-plaintext highlighter-rouge">P</code> where <code class="language-plaintext highlighter-rouge">P &lt;= B</code>.</li>
  <li>You have done a fast-sync, pivot block <code class="language-plaintext highlighter-rouge">P</code> where <code class="language-plaintext highlighter-rouge">P &gt; B</code>.</li>
  <li>You have done a full-sync, with pruning</li>
  <li>You have done a full-sync, without pruning (<code class="language-plaintext highlighter-rouge">--gcmode=archive</code>)</li>
</ol>

<p>Here’s what happens in each respective case:</p>

<ol>
  <li>Geth will regenerate the desired state by replaying blocks from the closest point ina
time before <code class="language-plaintext highlighter-rouge">B</code> where it has full state. This defaults to <code class="language-plaintext highlighter-rouge">128</code> blocks max, but you can
specify more in the actual call <code class="language-plaintext highlighter-rouge">... "reexec":1000 .. }</code> to the tracer.</li>
  <li>Sorry, can’t be done without replaying from genesis.</li>
  <li>Same as 1)</li>
  <li>Does not need to replay anything, can immediately load up the state and serve the request.</li>
</ol>


    </div>